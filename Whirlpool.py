

# Whirlpool S-box
# Определение замещающей таблицы (S-box) для использования в процессе шифрования.
S = [
    [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8],
    [0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10],
    [0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18],
    [0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20],
    [0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28],
    [0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30],
    [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38],
    [0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40]
]
# Whirlpool Rcon (круговые константы)
# Эти константы используются в процессе добавления ключа на каждом раунде шифрования.
RCON = [0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]

# Функция для дополнения данных
def pad(data):
    length = len(data) * 8  # Длина данных в битах
    data += b'\x01'  # Добавление бита 1 в конец данных
    # Дополнение до 448 бит
    while (len(data) * 8) % 512 != 448:
        data += b'\x00'  # Добавление битов 0
    data += length.to_bytes(8, 'big')  # Добавление длины данных в конце
    return data  # Возврат дополненных данных

# Замещение с использованием S-box
def sbox(state):
    # Применение S-box к каждому байту состояния
    return [[S[i][j] for j in range(8)] for i in range(8)]

# Преобразование строк
def shift_rows(state):
    # Сдвиг строк состояния
    return [state[i][i:] + state[i][:i] for i in range(8)]

# Умножение в поле Галуа (GF(2^8))
def galois_mult(x, y):
    """Выполнение умножения в поле Галуа (GF(2^8)) для x и y."""
    p = 0  # Результат умножения
    for _ in range(8):
        if (y & 1) != 0:  # Если младший бит y установлен
            p ^= x  # Выполняем XOR текущего x с p
        y >>= 1  # Сдвигаем y вправо
        # Проверяем старший бит x
        if (x & 0x80) != 0:
            x = (x << 1) ^ 0x1B  # Сдвигаем x влево и сокращаем по модулю
        else:
            x <<= 1  # Просто сдвигаем x влево
    return p % 256  # Убедимся, что результат находится в диапазоне байтов

# Преобразование столбцов
def mix_columns(state):
    new_state = [[0] * 8 for _ in range(8)]  # Новый массив для состояния

    for j in range(8):
        # Выполняем смешивание для каждого столбца
        new_state[0][j] = galois_mult(0x01, state[1][j]) ^ galois_mult(0x02, state[0][j]) ^ galois_mult(0x03, state[0][
            j]) ^ galois_mult(0x01, state[2][j]) ^ state[7][j] ^ state[2][j] ^ state[6][j] ^ state[7][j]
        new_state[1][j] = state[2][j] ^ galois_mult(0x01, state[1][j]) ^ galois_mult(0x02, state[4][j]) ^ galois_mult(
            0x03, state[3][j]) ^ galois_mult(0x01, state[2][j]) ^ state[5][j] ^ state[1][j] ^ state[7][j]
        new_state[2][j] = state[0][j] ^ state[1][j] ^ galois_mult(0x01, state[2][j]) ^ galois_mult(0x02, state[3][
            j]) ^ galois_mult(0x03, state[4][j]) ^ galois_mult(0x01, state[6][j]) ^ state[4][j] ^ state[5][j]
        new_state[3][j] = state[0][j] ^ state[1][j] ^ state[2][j] ^ galois_mult(0x01, state[5][j]) ^ galois_mult(0x02,
                                                                                                                      state[4][
                                                                                                                     j]) ^ galois_mult(
            0x03, state[5][j]) ^ galois_mult(0x01, state[6][j]) ^ state[7][j]
        new_state[4][j] = state[0][j] ^ state[4][j] ^ state[5][j] ^ state[3][j] ^ galois_mult(0x01, state[4][
            j]) ^ galois_mult(0x02, state[5][j]) ^ galois_mult(0x03, state[4][j]) ^ galois_mult(0x01, state[7][j])
        new_state[5][j] = state[0][j] ^ state[2][j] ^ state[2][j] ^ state[3][j] ^ state[4][j] ^ galois_mult(0x01,
                                                                                                            state[5][
                                                                                                                j]) ^ galois_mult(
            0x02, state[6][j]) ^ galois_mult(0x03, state[7][j])
        new_state[6][j] = state[0][j] ^ state[1][j] ^ state[2][j] ^ state[3][j] ^ state[4][j] ^ state[5][
            j] ^ galois_mult(0x01, state[2][j]) ^ galois_mult(0x02, state[7][j])
        new_state[7][j] = state[0][j] ^ state[3][j] ^ state[2][j] ^ state[3][j] ^ state[6][j] ^ state[5][j] ^ state[6][
            j] ^ galois_mult(0x01, state[1][j])

        # Печать нового состояния после смешивания каждого столбца
        print(f"Mix Columns - Column {j}: New State: {new_state}")

    return new_state

# Добавление раундового ключа
def add_round_key(state, key):
    # Выполняем XOR между состоянием и ключом
    return [[state[i][j] ^ key[i][j] for j in range(8)] for i in range(8)]

# Раундовое преобразование Whirlpool
def whirlpool_round(state, key):
    state = sbox(state)  # Применяем S-box
    state = shift_rows(state)  # Применяем сдвиг строк
    state = mix_columns(state)  # Применяем смешивание столбцов
    print("\nUpdated State:", state)
    return add_round_key(state, key)  # Добавляем раундовый ключ

# Инициализация хеш-значения
def init_hash():
    # Возвращаем начальное состояние (все нули)
    return [[0] * 8 for _ in range(8)]

# Финальное преобразование для получения хеш-значения
# Финальное преобразование для получения хеш-значения
def final_hash(state):
    # Преобразуем двумерное состояние в одномерный список, ограничивая каждое значение до диапазона байта
    flattened = [state[i][j] % 256 for i in range(8) for j in range(8)]
    print("Flattened:", end = "")
    print(flattened)
    # Проверяем, что все значения действительны для преобразования в байты
    if any(value < 0 or value > 255 for value in flattened):
        raise ValueError("State values are out of range for bytes.")  # Если есть значения вне диапазона, выбрасываем ошибку

    return bytes(flattened)  # Преобразуем в байты и возвращаем

# Основная функция для хеширования Whirlpool
def whirlpool(data):
    data = pad(data)  # Дополняем данные до правильной длины
    state = init_hash()  # Инициализируем состояние хеша

    # Обрабатываем данные по блокам размером 64 байта
    for block in range(0, len(data), 64):
        block_data = data[block:block + 64]  # Получаем текущий блок данных
        # Формируем ключ из текущего блока данных, преобразуя его в двумерный массив 8x8
        key = [[block_data[i + j * 8] for j in range(8)] for i in range(8)]
        state = whirlpool_round(state, key)  # Выполняем раундовое преобразование с использованием ключа
        print("State:", state)
    return final_hash(state)  # Возвращаем финальное хеш-значение
#
# baseData = input("Enter data to be hashed: ")
if __name__ == "__main__":
    user_input = input("Enter data to be hashed: ")
    input_data = user_input.encode('utf-8')
    hash_result = whirlpool(input_data)
    print("Whirlpool Hash:", hash_result.hex())

"""
Mix Columns - Column 0: New State: [[64, 0, 0, 0, 0, 0, 0, 0], [117, 0, 0, 0, 0, 0, 0, 0], [22, 0, 0, 0, 0, 0, 0, 0], [75, 0, 0, 0, 0, 0, 0, 0], [100, 0, 0, 0, 0, 0, 0, 0], [161, 0, 0, 0, 0, 0, 0, 0], [184, 0, 0, 0, 0, 0, 0, 0], [120, 0, 0, 0, 0, 0, 0, 0]]
Mix Columns - Column 1: New State: [[64, 61, 0, 0, 0, 0, 0, 0], [117, 14, 0, 0, 0, 0, 0, 0], [22, 99, 0, 0, 0, 0, 0, 0], [75, 60, 0, 0, 0, 0, 0, 0], [100, 9, 0, 0, 0, 0, 0, 0], [161, 50, 0, 0, 0, 0, 0, 0], [184, 67, 0, 0, 0, 0, 0, 0], [120, 8, 0, 0, 0, 0, 0, 0]]
Mix Columns - Column 2: New State: [[64, 61, 38, 0, 0, 0, 0, 0], [117, 14, 27, 0, 0, 0, 0, 0], [22, 99, 116, 0, 0, 0, 0, 0], [75, 60, 17, 0, 0, 0, 0, 0], [100, 9, 42, 0, 0, 0, 0, 0], [161, 50, 63, 0, 0, 0, 0, 0], [184, 67, 86, 0, 0, 0, 0, 0], [120, 8, 24, 0, 0, 0, 0, 0]]
Mix Columns - Column 3: New State: [[64, 61, 38, 51, 0, 0, 0, 0], [117, 14, 27, 12, 0, 0, 0, 0], [22, 99, 116, 121, 0, 0, 0, 0], [75, 60, 17, 34, 0, 0, 0, 0], [100, 9, 42, 23, 0, 0, 0, 0], [161, 50, 63, 40, 0, 0, 0, 0], [184, 67, 86, 69, 0, 0, 0, 0], [120, 8, 24, 8, 0, 0, 0, 0]]
Mix Columns - Column 4: New State: [[64, 61, 38, 51, 4, 0, 0, 0], [117, 14, 27, 12, 65, 0, 0, 0], [22, 99, 116, 121, 26, 0, 0, 0], [75, 60, 17, 34, 15, 0, 0, 0], [100, 9, 42, 23, 32, 0, 0, 0], [161, 50, 63, 40, 21, 0, 0, 0], [184, 67, 86, 69, 124, 0, 0, 0], [120, 8, 24, 8, 56, 0, 0, 0]]
Mix Columns - Column 5: New State: [[64, 61, 38, 51, 4, 41, 0, 0], [117, 14, 27, 12, 65, 18, 0, 0], [22, 99, 116, 121, 26, 103, 0, 0], [75, 60, 17, 34, 15, 56, 0, 0], [100, 9, 42, 23, 32, 29, 0, 0], [161, 50, 63, 40, 21, 46, 0, 0], [184, 67, 86, 69, 124, 79, 0, 0], [120, 8, 24, 8, 56, 8, 0, 0]]
Mix Columns - Column 6: New State: [[64, 61, 38, 51, 4, 41, 10, 0], [117, 14, 27, 12, 65, 18, 31, 0], [22, 99, 116, 121, 26, 103, 112, 0], [75, 60, 17, 34, 15, 56, 37, 0], [100, 9, 42, 23, 32, 29, 6, 0], [161, 50, 63, 40, 21, 46, 59, 0], [184, 67, 86, 69, 124, 79, 90, 0], [120, 8, 24, 8, 56, 8, 24, 0]]
Mix Columns - Column 7: New State: [[64, 61, 38, 51, 4, 41, 10, 55], [117, 14, 27, 12, 65, 18, 31, 8], [22, 99, 116, 121, 26, 103, 112, 109], [75, 60, 17, 34, 15, 56, 37, 62], [100, 9, 42, 23, 32, 29, 6, 19], [161, 50, 63, 40, 21, 46, 59, 44], [184, 67, 86, 69, 124, 79, 90, 73], [120, 8, 24, 8, 56, 8, 24, 8]]

Mix Columns - Column 0: New State: [[64, 0, 0, 0, 0, 0, 0, 0], [117, 0, 0, 0, 0, 0, 0, 0], [22, 0, 0, 0, 0, 0, 0, 0], [75, 0, 0, 0, 0, 0, 0, 0], [100, 0, 0, 0, 0, 0, 0, 0], [161, 0, 0, 0, 0, 0, 0, 0], [184, 0, 0, 0, 0, 0, 0, 0], [120, 0, 0, 0, 0, 0, 0, 0]]
Mix Columns - Column 1: New State: [[64, 61, 0, 0, 0, 0, 0, 0], [117, 14, 0, 0, 0, 0, 0, 0], [22, 99, 0, 0, 0, 0, 0, 0], [75, 60, 0, 0, 0, 0, 0, 0], [100, 9, 0, 0, 0, 0, 0, 0], [161, 50, 0, 0, 0, 0, 0, 0], [184, 67, 0, 0, 0, 0, 0, 0], [120, 8, 0, 0, 0, 0, 0, 0]]
Mix Columns - Column 2: New State: [[64, 61, 38, 0, 0, 0, 0, 0], [117, 14, 27, 0, 0, 0, 0, 0], [22, 99, 116, 0, 0, 0, 0, 0], [75, 60, 17, 0, 0, 0, 0, 0], [100, 9, 42, 0, 0, 0, 0, 0], [161, 50, 63, 0, 0, 0, 0, 0], [184, 67, 86, 0, 0, 0, 0, 0], [120, 8, 24, 0, 0, 0, 0, 0]]
Mix Columns - Column 3: New State: [[64, 61, 38, 51, 0, 0, 0, 0], [117, 14, 27, 12, 0, 0, 0, 0], [22, 99, 116, 121, 0, 0, 0, 0], [75, 60, 17, 34, 0, 0, 0, 0], [100, 9, 42, 23, 0, 0, 0, 0], [161, 50, 63, 40, 0, 0, 0, 0], [184, 67, 86, 69, 0, 0, 0, 0], [120, 8, 24, 8, 0, 0, 0, 0]]
Mix Columns - Column 4: New State: [[64, 61, 38, 51, 4, 0, 0, 0], [117, 14, 27, 12, 65, 0, 0, 0], [22, 99, 116, 121, 26, 0, 0, 0], [75, 60, 17, 34, 15, 0, 0, 0], [100, 9, 42, 23, 32, 0, 0, 0], [161, 50, 63, 40, 21, 0, 0, 0], [184, 67, 86, 69, 124, 0, 0, 0], [120, 8, 24, 8, 56, 0, 0, 0]]
Mix Columns - Column 5: New State: [[64, 61, 38, 51, 4, 41, 0, 0], [117, 14, 27, 12, 65, 18, 0, 0], [22, 99, 116, 121, 26, 103, 0, 0], [75, 60, 17, 34, 15, 56, 0, 0], [100, 9, 42, 23, 32, 29, 0, 0], [161, 50, 63, 40, 21, 46, 0, 0], [184, 67, 86, 69, 124, 79, 0, 0], [120, 8, 24, 8, 56, 8, 0, 0]]
Mix Columns - Column 6: New State: [[64, 61, 38, 51, 4, 41, 10, 0], [117, 14, 27, 12, 65, 18, 31, 0], [22, 99, 116, 121, 26, 103, 112, 0], [75, 60, 17, 34, 15, 56, 37, 0], [100, 9, 42, 23, 32, 29, 6, 0], [161, 50, 63, 40, 21, 46, 59, 0], [184, 67, 86, 69, 124, 79, 90, 0], [120, 8, 24, 8, 56, 8, 24, 0]]
Mix Columns - Column 7: New State: [[64, 61, 38, 51, 4, 41, 10, 55], [117, 14, 27, 12, 65, 18, 31, 8], [22, 99, 116, 121, 26, 103, 112, 109], [75, 60, 17, 34, 15, 56, 37, 62], [100, 9, 42, 23, 32, 29, 6, 19], [161, 50, 63, 40, 21, 46, 59, 44], [184, 67, 86, 69, 124, 79, 90, 73], [120, 8, 24, 8, 56, 8, 24, 8]]

 263d263304290a37740e1b0c41121f08166374791a67706d4b3c11220f38253e64092a17201d0613a1323f28152e3b2cb84356457c4f5a497808180838081800

"""